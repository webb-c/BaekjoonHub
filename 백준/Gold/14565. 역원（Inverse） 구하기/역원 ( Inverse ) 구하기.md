### 아이디어

모듈러 역원을 구하기만하는 아주 단순한 문제이다. 내가 모듈러 곱셈의 역원을 구하는 방법을 몰랐다는 점을 재외하면.

모듈러 덧셈의 역원은 residue system $Z_n$ 에서 덧셈의 항등원인 0과 동일한 의미를 가지는 n를 만들어내는 값을 찾으면 되기 떄문에 $(a+b) ≡ 0 \mod n$ 일 때, $b = n - a$ 로 쉽게 구할 수 있다.
그러나 모듈러 곱셈의 역원은 암호학 수업시간에 $(ab) ≡ 1 \mod n$ 을 만족하는 곱셈의 역원이 반드시 $\gcd(a, n) = 1$ 일 때만 존재한다는 사실은 알고 있었으나, 존재하는 곱셈의 역원을 어떻게 "**효율적으로 계산**"할 지에 대해서는 배우지 않았었다.

residue system에서 곱셈의 항등원인 1과 동일한 의미를 가지는 값은 $i\cdot n + 1$ 인데, 처음에는 가능한 모든 $i$ 범위에 대해서 찾아가면서 조건을 만족하는 값을 찾는 방식으로 코드를 구성했었다.

```python
if get_gcd(a, n) != 1:
    reverse_mul = -1
else:
    for i in range(1, n):
        if (a*i) % n == 1:
            reverse_mul = i
            break
```

이렇게 구하면 정의에 의해 구하는 것이기 때문에 명확한 값을 얻을 수 있지만, n에 따라 시간복잡도가 O(n)을 가지게 되는데 본 문제의 입력범위는 $10^12$인데 시간제한인 1초라서 O(n) 시간복잡도를 가지는 이 알고리즘으로는 문제를 해결할 수 없다.

그렇다면 어떻게 모듈로 곱셈의 역원을 구할 수 있을까? 그 답은 바로 "확장 유클리드 호제법"을 적용하는 것이다.
아이디어는 다음과 같다.
모듈로 곱셈의 역원을 가진다는 것은 $\gcd(a, n) = 1$ 이라는 의미이므로, $as + nt = 1$ 를 만족하는 $s, t$가 반드시 존재한다는 것을 알 수 있고, 이 식의 양변에 $\mod n$ 을 하게 되면 $nt$는 n의 배수이기 때문에 사라지고, 따라서 $as ≡ 1 \mod n$ 만 남게 된다. 즉, $s$가 $a$의 모듈러 곱셈의 역원이 되는 것이다!

따라서 확장 유클리드 호제법을 적용하여 $as + nt = 1$을 만족하는 s, t를 찾고 $s$를 답으로 반환하면 된다.

<br>

### 회고

확장 유클리드 호제법이 모듈러 역원을 구하는 것에도 사용된다는 걸 알 수 있었다.
또 확장 유클리드 호제법을 실제로 코드로 구현하는 것이 처음이어서 수학적 개념이 구현되어 실제 사용되는점이 꽤 신기했다.
